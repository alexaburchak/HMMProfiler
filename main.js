import { spawn } from "node:child_process";
import fs from "node:fs";
import os from "node:os";
import path from "node:path";
import csv from "csv-parser";
import { get_config_by_path, get_config_path_by_args } from "./src/config.js";

/**
 * Define function to process all sequences from fastq
 * @param {string} fastq_path
 * @param {number} min_quality
 * @param {string} fullFastaPath
 * @returns {Promise<void>}
 */
async function fullSeqKit(fastq_path, min_quality, fullFastaPath) {
	return new Promise((resolve, reject) => {
		// Construct full shell command as a single string
		const command = `seqkit seq --min-qual ${min_quality} ${fastq_path} | seqkit translate -f 6 -F > ${fullFastaPath}`;
		const seqkitFull = spawn(command, { shell: true });

		// Handle stdout and stderr for logging
		seqkitFull.stdout.on("data", (data) => {
			console.log(`Output: ${data}`);
		});

		seqkitFull.stderr.on("data", (data) => {
			console.error(`Error: ${data}`);
		});

		// Handle process termination
		seqkitFull.on("close", (code) => {
			if (code === 0) {
				console.log(`Translated sequences saved to: ${fullFastaPath}`);
				resolve();
			} else {
				console.error(`Process exited with code ${code}`);
				reject(new Error(`Process failed with exit code ${code}`));
			}
		});

		// Handle process error
		seqkitFull.on("error", (err) => {
			console.error(`Failed to start process: ${err.message}`);
			reject(new Error(`Failed to start process: ${err.message}`));
		});

		// Handle file stream errors
		fs.createWriteStream(fullFastaPath).on("error", (err) => {
			console.error(`Failed to write to sample.fasta: ${err.message}`);
			reject(new Error(`Failed to write to sample.fasta: ${err.message}`));
		});
	});
}

/**
 * Define function to run hmmsearch
 * @param {string} modelPath
 * @param {string} fastaPath
 * @param {string} outputPath
 * @param {string} stdoutPath
 * @returns {Promise<void>}
 */
async function runHMMSearch(modelPath, fastaPath, outputPath, stdoutPath) {
	// Return a Promise that wraps the asynchronous execution of hmmsearch
	return new Promise((resolve, reject) => {
		const hmmsearch = spawn("hmmsearch", [
			"-E",
			"1e-5", // e-value threshold
			"--domtblout",
			outputPath, // hmmsearch output is written to specified output file
			modelPath,
			fastaPath,
		]);

		// Create stream for the stdout file
		const stdoutStream = fs.createWriteStream(stdoutPath, { flags: "a" });

		// Capture and write any data from stdout to the file
		hmmsearch.stdout.on("data", (data) => {
			stdoutStream.write(data);
		});

		// Capture and log any error messages generated by hmmsearch
		hmmsearch.stderr.on("data", (data) => {
			console.error(`stderr: ${data}`);
		});

		hmmsearch.on("close", (code) => {
			// Check exit code to determine if hmmsearch was successful
			if (code === 0) {
				console.log(
					`hmmsearch completed successfully. Output written to ${outputPath}`,
				);
				stdoutStream.end(); // Close the stdout file stream
				resolve();
			} else {
				// If exit code is non-zero, an error occurred
				reject(new Error(`hmmsearch process exited with code ${code}`));
			}
		});
	});
}

/**
 * Define function to parse full hmmsearch output
 * @param {string} hmmerOut
 * @returns {Promise<Array<{
 * target_name: string,
 * score: number,
 * e_value: number,
 * ali_from: number,
 * ali_to: number}>>}
 */
async function parseFullHMMOutput(hmmerOut) {
	try {
		const lines = (await fs.promises.readFile(hmmerOut, "utf8")).split("\n");
		const parsedData = [];

		// Parse valid entries
		for (const line of lines) {
			if (line.startsWith("#") || line.trim() === "") {
				continue;
			}

			const columns = line.trim().split(/\s+/);
			if (columns.length < 23) {
				continue;
			}

			// Extract relevant columns
			const entry = {
				target_name: columns[0], // Target sequence name
				score: Number.parseFloat(columns[7]), // Bit score
				e_value: Number.parseFloat(columns[6]), // E-value
				ali_from: Number.parseInt(columns[17], 10), // Alignment start
				ali_to: Number.parseInt(columns[18], 10), // Alignment end
			};

			parsedData.push(entry);
		}

		/**
		 * bestEntries: Record to store highest-scoring hmmsearch hit for each target sequence
		 * @type {Record<string, {target_name: string, score: number, e_value: number, ali_from: number, ali_to: number} >}
		 * */
		const bestEntries = {};

		// Group entries by target_name and select the highest scoring row per target
		for (const entry of parsedData) {
			const key = entry.target_name;
			const entryForTarget = bestEntries[key];

			// Keep the highest-scoring entry per target_name
			if (entryForTarget === undefined) {
				bestEntries[key] = entry; // if this is the first time encountering this target, save it to bestEntries
			} else if (entryForTarget.score < entry.score) {
				bestEntries[key] = entry; // if this entry of target is greater than the current bestEntries, replace
			}
		}

		return Object.values(bestEntries);
	} catch (error) {
		if (error instanceof Error) {
			console.error(`Error parsing hmmsearch output: ${error.message}`);
		} else {
			console.error("Unknown error occurred.");
		}
		throw error;
	}
}

/**
 * Define function to parse FASTA file and store sequences by target_name
 * @param {string} fastaFilePath
 * @returns {Promise<Object<string, string>>}
 */
async function parseFasta(fastaFilePath) {
	try {
		const data = await fs.promises.readFile(fastaFilePath, "utf8");
		const lines = data.trim().split("\n");
		/**
		 * sequences: Object to store parsed sequences
		 * @type {Record<string, string>}
		 * */
		const sequences = {};

		// Temporary variables to store current sequence data
		let targetName = "";
		let sequence = "";

		for (const line of lines) {
			if (line.startsWith(">")) {
				// Save the previous sequence when a new header line is detected
				if (targetName) {
					sequences[targetName] = sequence;
				}
				// Extract target name and reset sequence
				targetName = line.substring(1).split(" ")[0];
				sequence = "";
			} else {
				// Append sequence data
				sequence += line.trim();
			}
		}

		// Ensure the last sequence in file is added to the object
		if (targetName) {
			sequences[targetName] = sequence;
		}

		return sequences;
	} catch (error) {
		if (error instanceof Error) {
			console.error(`Error parsing FASTA file: ${error.message}`);
		} else {
			console.error("Unknown error occurred.");
		}
		throw error;
	}
}

/**
 * Define function to merge HMMER output and fasta sequences by target_name
 * @param {string} hmmerFilePath
 * @param {string} fastaFilePath
 * @param {string} fastqFilePath
 * @param {string} hmmFilePath
 * @returns {Promise<Array<{
 * target_name: string,
 * score: number,
 * e_value: number,
 * ali_from: number,
 * ali_to: number,
 * sequence: string,
 * FASTQ_filename: string,
 * model_name: string,
 * trimmed_seq: string,
 * seq_len: number,
 * start_pos: number}>>}
 */
async function mergeData(
	hmmerFilePath,
	fastaFilePath,
	fastqFilePath,
	hmmFilePath,
) {
	// Parse HMMER output and FASTA file
	const [hmmerData, fastaData] = await Promise.all([
		parseFullHMMOutput(hmmerFilePath),
		parseFasta(fastaFilePath),
	]);

	// Extract filenames from paths
	const fastqFilename = fastqFilePath.split("/").pop() || "";
	const modelName = hmmFilePath.split("/").pop() || "";

	// Create array
	const mergedData = [];

	for (const entry of hmmerData) {
		const fullSequence = fastaData[entry.target_name]; // Extract full sequence for target_name from the fasta file
		const trimmedSeq = fullSequence.slice(entry.ali_from - 1, entry.ali_to); // Trim sequence
		const seqLen = trimmedSeq.length; // Calculate trimmed sequence length

		// Extract start position from target_name
		const match = entry.target_name.match(/frame=(-?\d+)/);
		const startPos = match ? Number.parseInt(match[1], 10) : 0; // if no match is found, startPos is set to 0

		// Remove "frame=" information from target_name
		const cleanedTargetName = entry.target_name
			.replace(/_frame=-?\d+/, "")
			.trim();

		mergedData.push({
			...entry,
			target_name: cleanedTargetName,
			sequence: fullSequence, // Attach full FASTA sequence
			FASTQ_filename: fastqFilename,
			model_name: modelName, // HMM filename
			trimmed_seq: trimmedSeq,
			seq_len: seqLen,
			start_pos: startPos, // Start position for translation
		});
	}

	return mergedData;
}

/**
 * Define function to count occurrences of unique sequence combinations for all model_names
 * @param {string} mergedDataPath
 * @returns {Promise<Array<Record<string, any>>>} - each object in array represents a unique sequence combination and its count
 */
async function countSeqs(mergedDataPath) {
	return new Promise((resolve, reject) => {
		/**
		 * targetSequences: Object to store trimmed sequence data, indexed by target_name
		 * Each target_name maps to an object containing model_name keys with their respective trimmed sequences
		 * @type {Object.<string, Object.<string, string>>}
		 */
		const targetSequences = {};

		fs.createReadStream(mergedDataPath)
			.pipe(csv()) // Parse CSV file line by line
			.on("data", (entry) => {
				const { target_name, model_name, trimmed_seq } = entry;
				const modelKey = model_name.toLowerCase();

				// Initialize target entry if missing
				if (!targetSequences[target_name]) {
					targetSequences[target_name] = {};
				}

				// Assign trimmed sequence to the corresponding model_name
				targetSequences[target_name][modelKey] ??= trimmed_seq;
			})
			.on("end", () => {
				/**
				 * seqCounts: Object to store counts of unique sequence combos across all targets
				 * @type {Object.<string, { sequences: object, count: number }>}
				 */
				const seqCounts = {};

				for (const sequences of Object.values(targetSequences)) {
					// Create unique key for this sequence combination
					const seqKey = Object.entries(sequences)
						.sort(([keyA], [keyB]) => keyA.localeCompare(keyB)) // Sort model names for consistency
						.map(([model, seq]) => `${model}:${seq}`) // Convert each model-seq pair to string
						.join("|"); // Create single key by joining strings

					// Increment count for this unique sequence combination
					if (!seqCounts[seqKey]) {
						seqCounts[seqKey] = { sequences, count: 0 };
					}
					seqCounts[seqKey].count++;
				}

				// Convert object into an array and sort by descending count
				const sortedResults = Object.values(seqCounts).sort(
					(a, b) => b.count - a.count,
				);

				/// Format data for CSV output
				const formattedResults = sortedResults.map(({ sequences, count }) => ({
					...Object.fromEntries(
						Object.entries(sequences).map(([model, seq]) => [
							`${model.replace(/\.[^.]+$/, "")}_seq`, // Remove file extension
							seq,
						]),
					),
					count,
				}));

				resolve(formattedResults);
			})
			.on("error", (error) => reject(error));
	});
}

/**
 * Define function to write/append merged output to CSV
 * @param {string} outputFile
 * @param {Array<Record<string, any>>} data
 * @param {boolean} append
 */
async function writeCsv(outputFile, data, append = false) {
	try {
		const header = Object.keys(data[0]);
		const rows = data.map((row) =>
			header.map((col) => row[col] || "").join(","),
		);
		const csvContent = rows.join("\n");

		// Check if the file exists and append data instead of overwriting
		if (append && fs.existsSync(outputFile)) {
			fs.appendFileSync(outputFile, `\n${csvContent}`, "utf8");
		} else {
			fs.writeFileSync(
				outputFile,
				[header.join(","), csvContent].join("\n"),
				"utf8",
			);
		}

		console.log(`CSV updated: ${outputFile}`);
	} catch (error) {
		if (error instanceof Error) {
			console.error(`Error writing CSV: ${error.message}`);
		} else {
			console.error("Unknown error occurred.");
		}
		throw error;
	}
}

/**
 * Define function to zip output files
 * @param {string} inputFile
 */
function compressFile(inputFile) {
	const gzip = spawn("gzip", [inputFile]);

	// Listen for errors
	gzip.stderr.on("data", (data) => {
		console.error(`stderr: ${data}`);
	});

	// Listen for when the process finishes
	gzip.on("close", (code) => {
		if (code === 0) {
			console.log(`File successfully compressed: ${inputFile}.gz`);
		} else {
			console.error(`gzip process for ${inputFile} exited with code ${code}`);
		}
	});
}

// Define main function
async function main() {
	// Read config
	const config_path = await get_config_path_by_args();
	const config = get_config_by_path(config_path);
	console.log(config);
	if (config === null) {
		return; // exit program if config is null
	}

	// Extract parameters from config object
	const { matches_outpath, counts_outpath, min_quality, input_pairs } = config;

	// Create temporary directory for intermediate files
	const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "processing-"));

	try {
		// Loop over input pairs
		for (const { fastq_path, model_path } of input_pairs) {
			console.log(`Processing: ${fastq_path} with model ${model_path}`);

			// Define intermediate output paths within temp directory
			const fullFastaPath = path.join(tempDir, "full.fasta");
			const domtbloutPath = path.join(tempDir, "hmmsearch_out.tbl");
			const stdoutPath = path.join(tempDir, "hmmer_stdout.tbl");

			try {
				// Translate sequences in all 6 frames
				await fullSeqKit(fastq_path, min_quality, fullFastaPath);

				// Run HMMER on all translated sequences
				await runHMMSearch(
					model_path,
					fullFastaPath,
					domtbloutPath,
					stdoutPath,
				);

				// Merge hmmsearch results with sequence information and trim based on match results
				const mergedData = await mergeData(
					domtbloutPath,
					fullFastaPath,
					fastq_path,
					model_path,
				);

				await writeCsv(matches_outpath, mergedData, true);
				console.log("Matches written to:", matches_outpath);
			} catch (error) {
				if (error instanceof Error) {
					console.error(error.message);
				} else {
					console.error("Unknown error occurred.");
				}
				throw error;
			}
		}

		// Count unique VH/VL pairs after all input pairs are processed
		try {
			const countData = await countSeqs(matches_outpath);
			await writeCsv(counts_outpath, countData, true);
			console.log("Final counts written to:", counts_outpath);
		} catch (error) {
			if (error instanceof Error) {
				console.error("Error in countSeqs:", error.message);
			} else {
				console.error("Unknown error occurred.");
			}
			throw error;
		}
	} finally {
		// Remove temporary directory and all its contents
		fs.rmSync(tempDir, { recursive: true, force: true });
		console.log("Temporary files cleaned up.");
	}

	// Zip output files
	compressFile(matches_outpath);
	compressFile(counts_outpath);
	console.log("Pipeline complete!");
}

// Execute main function
main().catch(console.error);